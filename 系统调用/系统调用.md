# 系统调用

进程一直忙着与内核交互：请求系统资源，访问外设，与其他进程通信，读取文件等。为达到上述目的，进程使用标准库例程，库例程接下来调用内核函数。最终，由内核负责在各个请求进程之间公平而且流畅地共享资源和服务

- 应用程序看到的内核是负责执行多种系统功能的一个大的例程集合。标准库是一个中间层，用于在不同的体系结构和系统之间，标准化并简化内核例程的管理
- 内核视角来看，因为用户态和核心态之间有几个重大的不同。两种模式下不同的虚拟地址空间和利用各种处理器特性的不同方式

## 系统程序设计基础





## 可用的系统调用

### 进程管理

进程处于系统的中心，因此进程管理方面有大量系统调用

1. fork和vfork将一个现存进程分支为两个新进程。clone是fork的增强版，除了具有fork功能，还支持创建线程

2. exit结束了一个进程并释放其资源

3. 有一大堆系统调用可用于查询(和设置)进程的属性，如PID、UID等。其中大多数调用只是读取或修改task_struct中的字段而已。

   系统调用按照一种合乎逻辑的方案来进行命名，如setgid，setuid，geteuid等

4. personality定义了应用程序的执行环境。例如，可用于二进制仿真的实现

5. ptrace使得能够跟踪系统调用，是strace工具的基础

6. nice设置普通进程的优先级，它给进程分配的优先级在[-20,19]之间，随数值升高优先级递减。只有root进程才能指定负的优先级值

7. setrlimit用于设置一定的资源限制。例如，CPU时间或子进程的最大容量数目。getrlimit查询当前的限制，而getrusage查询当前资源使用情况。检查进程是否合乎定义的资源限制

### 时间操作

不仅可用来查询和设置当前系统时间，还使进程能够执行基本时间的操作。

1. adjtimex读取和设置基于时间的内核变量，以控制内核在时间方面的行为
2. alarm和setitimer建立报警器和间隔定时器，将操作延迟到一个稍后的时间执行。getitimer考虑当前时区和夏令时的因素
3. sleep和nanosleep让进程执行暂停一个指定的时间段。nanasleep可以高精度的时间单位来指定暂停的时间段
4. time返回自1970年1月1日零时以来经过的秒数。

### 信号处理

信号是在进程之间交换有限信息以及促进进程间通信的最简单方法。

1. signal设置信号处理函数。sigaction是signal现代增强版本
2. sigpending检查进程当前是否有待决信号被阻塞
3. sigsuspend将进程置于等待队列上，直至某个特定的信号到达
4. setmask启用信号的阻塞机制，而getmask返回所有当前阻塞信号的列表
5. kill用于向一个进程发送任何信号
6. 还有一组处理实时信号的系统调用，但其对应的函数名带有前缀rt_。例如，rt_sigaction设置一个实时信号处理程序，而rt_sigsuspend将进程置于等待状态。直至某个特定(一组信号中的一个)信号到达

### 调度

与调度相关的系统调用可以归类到进程管理，因为所有此类调用都与系统进程有关。

- setpriority和getpriority分别设置和获取进程的优先级，因而是用于调度目的的关键系统调用
- Linux不仅支持不同的进程优先级，还提供多种调度类，以适应应用程序在时间方面具体行为和需求。sched_setscheduler和sched_getscheduler分别设置和查询调度类。sched_setparam和sched_getparam分别设置和查询进程的附加调度参数
- sched_yield自愿释放CPU的控制权，即使进程当前仍然有CPU时间可用

### 模块

系统调用还用于向内核增加模块和从内核移除模块

- init_module添加一个新模块
- delete_module从内核移除一个模块

### 文件系统

所有关于文件系统的系统调用都应用到VFS层的例程。从VFS层开始，各个调用转发到具体文件系统的实现，后者都会访问块层。从资源和执行时间来衡量，此类系统调用的代价都很高

- 一些系统调用被用作用户空间中同名实用程序的直接基础，用来创建和修改目录结构：chdir、mkdir、rmdir、rename、symlink、getcwd、chroot、umask、mknod
- 文件和目录属性可以用chown和chmod修改
- 用于处理文件内容，其实现在标准库中，与对应的系统调用同名：open、close、read和readv、write和writev、truncate和llseek
- readdir和getdents读取目录结构
- link、symlink和unlike创建和删除链接。readlink读取链接的内容
- mount和umount用于文件系统的装载和卸载
- poll和select用于等待某些事件
- execve装载一个新进程，替换旧的进程。与fork联合使用时，它会启动一个新的程序

### 内存管理

在通常的环境下，用户应用程序很少或从未接触到内存管理系统调用，因为这个领域被标准库的API屏蔽起来，C标准库提供malloc、balloc和calloc等函数。

- 就动态内存管理而言，最重要的调用是brk，它修改进程数据段的长度。调用malloc或相似函数的程序会频繁使用该系统调用
- mmap、mmap2、munmap和mremap执行内存映射、解除映射和重新映射操作，而mprotect控制对虚拟内存中特定区域的访问，madvice提供对特定虚拟内存的使用建议
- mmap和mmap2的参数稍有不同。默认情况，使用mmap2
- swapon和swapoff分别启用和禁用外存储器设备上的交换区

### 进程间通信和网络功能

因为进程间通信(IPC)和网络是比较复杂的问题，很容易臆断有大量相关的系统调用。但事实刚好相反，只有两个系统调用来处理所有可能的任务。但其中涉及了非常多的参数。C标准库将这些功能安排到许多不同的函数，这些函数只有少量参数，使程序员更容易处理

- socketcall处理网络方面的问题，用于实现套接字抽象。它管理各种类型的连接和协议，总共实现17种功能，通过SYS_ACCEPT、SYS_SENDTO等常数来区分。参数必须以指针形式传递，指向一个与函数类型相关的用户空间结构，其中保存了所需的数据
- ipc和socketcall相对应，用于处理计算机本地的连接，而不是通过网络建立的连接。因为该系统调用只需实现11种功能，它使用固定数目的参数来从用户空间向内核空间传递数据。

### 系统信息和设置

通常必需查询当前运行内核及其配置和系统配置的有关信息。类似地，需要设置内核参数，有些信息必需保存到系统日志文件。

- syslog向系统日志写入消息，并允许设置不同的优先级
- sysinfo返回有关系统状态的信息，特别有关内存使用的统计量。
- sysctl用于微调内核参数。内核现在支持大量的动态可配置选项，可以使用proc文件系统读取和修改

### 系统安全和能力

传统的UNIX安全模型基于用户，组和root用户，对现代需求而言已经不够灵活。这就导致引入了能力系统，该系统根据细粒度方案，使得非root进程能够拥有额外的权限和能力

- capset和capget负责设置和查询进程的能力
- security是一个系统调用的多路分解器，用于实现LSM

## 系统调用的实现

在系统调用的实现中，不仅需要讨论提供所需函数的内核源代码，还需要阐述调用这些函数的方式，这些函数的调用方式和普通的C函数不同，因为需要跨越用户态和核心态的边界。该代码尽可能快速地建立了一个独立于处理器的状态，使得系统调用的实现能够独立于底层体系结构。参数如何在用户空间和内核空间之间传递的问题也必须考虑

### 系统调用的结构

用于实现系统调用的内核代码划分为两个不同的部分

1. 系统调用执行的实际任务实现为一个C例程，与其余内核代码几乎没有差别
2. 用于调用该例程的机制则充满了平台相关的特性，必须考虑大量细节，因而最终实现使用汇编语言代码是必然的

**处理程序函数的实现**

用于实现系统调用的处理程序函数，在形式上有如下几种共同的特性

- 每个函数的名称前缀都是sys_，将该函数唯一地标识为一个系统调用，更精确地硕，标识为一个系统调用的处理程序函数。
- 所有的处理程序函数都最多接受5个参数。这些参数在参数列表中指定，与普通C函数相同
- 所有的系统调用都在核心态执行。


系统调用中各操作的时间顺序

```
用户空间：应用程序 -> C库 | 内核空间： -> 内核 -> 处理程序 -> 内核 | -> C库 -> 应用程序
```

形式上，只传递一个void指针，因为根据多路分解常数的不同，系统调用参数数目也会变化。

**调用分派和参数传递**		

系统调用由内核分配的一个编号唯一标识。在考虑触发系统调用的过程时，所有的系统调用都由一处中枢代码处理。根据调用编号和一个静态表，将调用分派到具体的函数。

参数传递

在所有平台，系统调用参数都是通过寄存器直接传递的，对具体的处理程序函数，参数与寄存器之间的映射是精确定义的。

- IA-32使用汇编语言指令$0x80来引发软件中断128
- Alpha处理器提供一种特权系统状态
- PowerPC处理器提供system call的汇编语言指令
- AMD64体系结构，也提供了自身的汇编语言，被称为syscall

系统调用表

用系统调用表的方法定义，和C数组类似，也可以用指针运算处理。sys_call_table是基指针，指向数组的起始处。如果调用open系统调用，传递编号5的系统调用。

syscall_table_32.S

```c
ENTRY(sys_call_table)
	.long sys_restart_syscall
	.long sys_exit
	.long sys_fork
	.long sys_read
	.long sys_wirte
	.long sys_open /* 5 */
	.long sys_close
```

返回用户态

系统调用返回值：负值表示错误，正值和0表示成功结束

最常见的系统调用错误码如下

- EACCES表示文件不能按指定的访问权限处理。例如，文件权限串没有写权限，则不能以写方式打开
- 如果试图创建已经存在的文件，则返回EEXIST
- ENOENT意味着目标文件不存在，而同时又没有指定允许创建不存在文件的标志

如果系统调用成功结束，则返回一个大于等于0的正数。能够返回到用户空间的错误码符号常熟不会大于511。

### 访问用户空间

有如下两种原因，内核必须访问应用程序的地址空间

- 如果一个系统调用需要超过6个不同的参数，它们只能借助进程内存空间中的C结构实例来传递。系统调用借助寄存器，将指向该结构实例的一个指针传递给内核
- 由系统调用的负效应产生的大量数据，不能通过返回值机制传递给用户进程。想法，必须通过指定的内存区交换该数据。

### 追踪系统调用

strace工具用来追踪进程的系统调用。使用的ptrace系统调用

ptrace在内核源代码中的定义需要4个参数

- pid标识了目标进程。进程标识符根据调用者的命名空间来解释
- addr和data向内核传递一个内存地址和附加信息
- 借助于符号常数，request用于选择一个操作，由ptrace执行，可用选项如下
  - PTRACE_ATTACH发出一个请求，连接一个进程并开始跟踪。PTRACE_DETACH从该进程断开并结束跟踪
  - PEEKTEXT、PEEKDATA和PEEKUSR从进程地址空间读取数据
  - POKETEXT、POKEDATA和PEEKUSR向被监控进程的三个指定区域写入值，因而可以操作进程地址空间的内容。
  - PTRACE_SETREGS和PTRACE_GETREGS设置和读取PCU的特权寄存器集合的值
  - PTRACE_SETFPREGS和PTRACE_GETFPREGS设置和读取用于浮点计算的寄存器。这些操作在测试和交互式调试应用程序时也非常有用
  - 系统调用追踪是基于PTRACE_SYSCALL的
  - PTRACE_SINGLESTEP将处理器在执行被追踪进程期间，置于单步执行环境
  - PTRACE_KILL发送KILL信号，关闭被追踪进程
  - PTRACE_TRACEME开始对当前进程的跟踪
  - PTRACE_CONT恢复被跟踪进程的执行

**系统调用追踪**

ptrace使用：将当前进程连接到一个进程，并检测系统调用的使用

程序大体结构

1. 从命令行读取被跟踪程序的pid，并进行通常的检查
2. 安装CHLD信号的一个处理程序，因为每次被跟踪程序中断时，内核都会向跟踪者进程发送该喜好
3. 跟踪者进程通过ptrace请求PTRACE_ATTACH，将自身连接到目标应用程序
4. 跟踪者程序的主体由一个简单的无限循环组成，其中重复调用wait目录。等待新的CHLD信号的到达

在通过PTRACE_ATTACH开始跟踪进程之后，大部分工作都委托给CHLD信号的处理程序函数，其实现在sigchld_handler中。该函数负责执行下列人物

- 使用平台相关的方法，帮助查找所调用系统调用的编号
- 帮助恢复被跟踪进程的控制流。当然，必须通知内核，该进程的执行将在下一个系统调用时暂停。这是使用ptrace请求PTRACE_SYSCALL完成的

在一个信号发送到被追踪进程时，内核也会想跟踪者发送一个SIGCHLD信号，则会调用对应的处理程序，与系统调用发生时相同。事实上，在发起跟踪时，内核会自动向被跟踪进程发送一个STOP信号，以确保在跟踪开始时调用处理程序。

**内核端实现**

ptrace系统调用的处理函数被称为sys_ptrace。

- 首先进行预备工作，主要使用ptrace_get_task_strucet确定所传递PDI对应的task_struct结构实例。
- 开始跟踪，如果设置了PTRACE_ATTACH，则用ptrace_attach建立跟踪者进程与目标进程之间的关联
  - 目标进程的ptrace成员设置为PT_TRACE
  - 跟踪者进程变为目标进程的父进程
  - 被跟踪者进程添加跟踪者的ptrace_children链表，使用task_struct的ptrace_list成员作为链表元素
  - 向被跟踪的进程发送一个STOP信号
- PTRACE_CONT和PTRACE_SYSCALL的实现。在被跟踪的进程因为受到信号暂停后，PTRACE_CONT将恢复其执行。该功能内核端实现关联PTRACE_SYSCALL
  - 在使用PTRACE_SYSCALL时，将在被监控进程的task_struct中，设置TIF_SYSCALL_TRACE标志。
  - 在使用PTRACE_CONT，使用clear_tsk_thread_flag删除该标志
- 停止跟踪，使用PTRACE_DETACH来停止跟踪。该任务由下列步骤组成
  1. 体系结构相关的挂钩ptrace_disable用来执行停止追踪所需的底层操作
  2. 从子进程的线程标志中，清除TIF_SYSCALL_TRACE
  3. 目标进程task_struct的ptrace成员重置为0，将目标进程从跟踪者进程的ptrace_children链表删除
  4. 将被跟踪进程的父进程重置为原父进程，即将task_struct -> parent赋值为real_parent
- 读取和修改目标进程的数据
  - addr指定将要读取的数据段中地址
  - data用于接收相关的结果

从某种角度来看，可以将内核视为一个综合性的库。它包含了各种可向用户层应用程序提供的功能。系统调用是应用程序与该库之间的接口。应用陈旭可以向内核请求一个服务，内核接下来满足该要求。








































